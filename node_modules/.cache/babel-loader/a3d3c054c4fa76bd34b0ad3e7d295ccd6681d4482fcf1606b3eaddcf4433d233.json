{"ast":null,"code":"import { jwtDecode } from 'jwt-decode';\n\n/**\n * Validates JWT token and returns decoded data if valid\n * @returns {Object|null} Decoded token or null if invalid\n */\nexport const validateToken = () => {\n  try {\n    const token = localStorage.getItem('token');\n    if (!token) return null;\n    const decoded = jwtDecode(token);\n    const currentTime = Date.now() / 1000;\n    if (decoded.exp < currentTime) {\n      console.warn('Token expired, exp:', decoded.exp, 'current:', currentTime);\n      return null; // Token expired\n    }\n    return decoded;\n  } catch (error) {\n    console.warn('Token validation error:', error);\n    return null;\n  }\n};\n\n/**\n * Gets user data from localStorage and token\n * @returns {Object|null} User data or null if not available\n */\nexport const getUserData = () => {\n  try {\n    const userStr = localStorage.getItem('user');\n    if (!userStr) return null;\n    const userData = JSON.parse(userStr);\n    const tokenData = validateToken();\n    if (tokenData) {\n      // Merge user data with token data\n      return {\n        ...userData,\n        role: tokenData.role || userData.role,\n        // Add token validation timestamp to track when this was last validated\n        _validated: Date.now()\n      };\n    }\n    return userData;\n  } catch (error) {\n    console.warn('Error getting user data:', error);\n    return null;\n  }\n};\n\n/**\n * Checks if user is authenticated\n * @returns {boolean} True if authenticated\n */\nexport const isAuthenticated = () => {\n  const tokenValid = !!validateToken();\n  const userData = getUserData();\n  if (!tokenValid) {\n    // If token is invalid but we're still trying to authenticate,\n    // check if we've exceeded max attempts\n    const authAttempts = parseInt(sessionStorage.getItem('auth_attempts') || '0');\n    if (authAttempts > 3) {\n      // Clear auth data after too many failed attempts\n      clearAuthData();\n      return false;\n    }\n\n    // Increment auth attempts\n    sessionStorage.setItem('auth_attempts', (authAttempts + 1).toString());\n  } else {\n    // Reset auth attempts counter on successful validation\n    sessionStorage.removeItem('auth_attempts');\n  }\n  return tokenValid && !!userData;\n};\n\n/**\n * Clears all authentication data\n */\nexport const clearAuthData = () => {\n  localStorage.removeItem('token');\n  localStorage.removeItem('user');\n  sessionStorage.removeItem('auth_attempts');\n\n  // Clear any axios headers\n  if (window.axios) {\n    delete window.axios.defaults.headers.common['Authorization'];\n  }\n};\n\n/**\n * Refreshes authentication state\n * @returns {boolean} True if refresh was successful\n */\nexport const refreshAuthState = () => {\n  const token = localStorage.getItem('token');\n  const userStr = localStorage.getItem('user');\n  if (!token || !userStr) return false;\n  try {\n    const decoded = validateToken();\n    if (!decoded) {\n      // If token is invalid, check if we should clear auth data\n      const authAttempts = parseInt(sessionStorage.getItem('auth_attempts') || '0');\n      if (authAttempts > 3) {\n        clearAuthData();\n      }\n      return false;\n    }\n\n    // Update axios headers\n    if (window.axios) {\n      window.axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;\n    }\n\n    // Reset auth attempts counter on successful validation\n    sessionStorage.removeItem('auth_attempts');\n    return true;\n  } catch (error) {\n    return false;\n  }\n};","map":{"version":3,"names":["jwtDecode","validateToken","token","localStorage","getItem","decoded","currentTime","Date","now","exp","console","warn","error","getUserData","userStr","userData","JSON","parse","tokenData","role","_validated","isAuthenticated","tokenValid","authAttempts","parseInt","sessionStorage","clearAuthData","setItem","toString","removeItem","window","axios","defaults","headers","common","refreshAuthState"],"sources":["C:/xampp/htdocs/sms-frontend-clone/src/utils/authUtils.js"],"sourcesContent":["import { jwtDecode } from 'jwt-decode';\n\n/**\n * Validates JWT token and returns decoded data if valid\n * @returns {Object|null} Decoded token or null if invalid\n */\nexport const validateToken = () => {\n  try {\n    const token = localStorage.getItem('token');\n    if (!token) return null;\n    \n    const decoded = jwtDecode(token);\n    const currentTime = Date.now() / 1000;\n    \n    if (decoded.exp < currentTime) {\n      console.warn('Token expired, exp:', decoded.exp, 'current:', currentTime);\n      return null; // Token expired\n    }\n    \n    return decoded;\n  } catch (error) {\n    console.warn('Token validation error:', error);\n    return null;\n  }\n};\n\n/**\n * Gets user data from localStorage and token\n * @returns {Object|null} User data or null if not available\n */\nexport const getUserData = () => {\n  try {\n    const userStr = localStorage.getItem('user');\n    if (!userStr) return null;\n    \n    const userData = JSON.parse(userStr);\n    const tokenData = validateToken();\n    \n    if (tokenData) {\n      // Merge user data with token data\n      return {\n        ...userData,\n        role: tokenData.role || userData.role,\n        // Add token validation timestamp to track when this was last validated\n        _validated: Date.now()\n      };\n    }\n    \n    return userData;\n  } catch (error) {\n    console.warn('Error getting user data:', error);\n    return null;\n  }\n};\n\n/**\n * Checks if user is authenticated\n * @returns {boolean} True if authenticated\n */\nexport const isAuthenticated = () => {\n  const tokenValid = !!validateToken();\n  const userData = getUserData();\n  \n  if (!tokenValid) {\n    // If token is invalid but we're still trying to authenticate,\n    // check if we've exceeded max attempts\n    const authAttempts = parseInt(sessionStorage.getItem('auth_attempts') || '0');\n    if (authAttempts > 3) {\n      // Clear auth data after too many failed attempts\n      clearAuthData();\n      return false;\n    }\n    \n    // Increment auth attempts\n    sessionStorage.setItem('auth_attempts', (authAttempts + 1).toString());\n  } else {\n    // Reset auth attempts counter on successful validation\n    sessionStorage.removeItem('auth_attempts');\n  }\n  \n  return tokenValid && !!userData;\n};\n\n/**\n * Clears all authentication data\n */\nexport const clearAuthData = () => {\n  localStorage.removeItem('token');\n  localStorage.removeItem('user');\n  sessionStorage.removeItem('auth_attempts');\n  \n  // Clear any axios headers\n  if (window.axios) {\n    delete window.axios.defaults.headers.common['Authorization'];\n  }\n};\n\n/**\n * Refreshes authentication state\n * @returns {boolean} True if refresh was successful\n */\nexport const refreshAuthState = () => {\n  const token = localStorage.getItem('token');\n  const userStr = localStorage.getItem('user');\n  \n  if (!token || !userStr) return false;\n  \n  try {\n    const decoded = validateToken();\n    if (!decoded) {\n      // If token is invalid, check if we should clear auth data\n      const authAttempts = parseInt(sessionStorage.getItem('auth_attempts') || '0');\n      if (authAttempts > 3) {\n        clearAuthData();\n      }\n      return false;\n    }\n    \n    // Update axios headers\n    if (window.axios) {\n      window.axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;\n    }\n    \n    // Reset auth attempts counter on successful validation\n    sessionStorage.removeItem('auth_attempts');\n    \n    return true;\n  } catch (error) {\n    return false;\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}