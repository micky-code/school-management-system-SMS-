{"ast":null,"code":"var _s = $RefreshSig$();\n/**\n * Custom React hook for polling data as WebSocket fallback\n */\nimport { useState, useEffect, useRef, useCallback } from 'react';\nconst usePolling = (fetchFunction, options = {}) => {\n  _s();\n  const {\n    interval = 5000,\n    enabled = true,\n    onSuccess,\n    onError,\n    dependencies = []\n  } = options;\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [lastUpdated, setLastUpdated] = useState(null);\n  const intervalRef = useRef(null);\n  const mountedRef = useRef(true);\n  const fetchData = useCallback(async () => {\n    if (!enabled || !mountedRef.current) return;\n    try {\n      setLoading(true);\n      setError(null);\n      const result = await fetchFunction();\n      if (mountedRef.current) {\n        setData(result);\n        setLastUpdated(new Date());\n        onSuccess === null || onSuccess === void 0 ? void 0 : onSuccess(result);\n      }\n    } catch (err) {\n      if (mountedRef.current) {\n        setError(err);\n        onError === null || onError === void 0 ? void 0 : onError(err);\n        console.error('Polling error:', err);\n      }\n    } finally {\n      if (mountedRef.current) {\n        setLoading(false);\n      }\n    }\n  }, [fetchFunction, enabled, onSuccess, onError]);\n  const startPolling = useCallback(() => {\n    if (intervalRef.current) {\n      clearInterval(intervalRef.current);\n    }\n    if (enabled) {\n      // Fetch immediately\n      fetchData();\n\n      // Then set up interval\n      intervalRef.current = setInterval(fetchData, interval);\n    }\n  }, [fetchData, interval, enabled]);\n  const stopPolling = useCallback(() => {\n    if (intervalRef.current) {\n      clearInterval(intervalRef.current);\n      intervalRef.current = null;\n    }\n  }, []);\n  const refreshData = useCallback(() => {\n    fetchData();\n  }, [fetchData]);\n\n  // Start/stop polling based on enabled state\n  useEffect(() => {\n    if (enabled) {\n      startPolling();\n    } else {\n      stopPolling();\n    }\n    return () => {\n      stopPolling();\n    };\n  }, [enabled, startPolling, stopPolling, ...dependencies]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      mountedRef.current = false;\n      stopPolling();\n    };\n  }, [stopPolling]);\n  return {\n    data,\n    loading,\n    error,\n    lastUpdated,\n    refreshData,\n    startPolling,\n    stopPolling\n  };\n};\n_s(usePolling, \"9qGYNAS2f03ilOO5WURjQOEbwFU=\");\nexport default usePolling;","map":{"version":3,"names":["useState","useEffect","useRef","useCallback","usePolling","fetchFunction","options","_s","interval","enabled","onSuccess","onError","dependencies","data","setData","loading","setLoading","error","setError","lastUpdated","setLastUpdated","intervalRef","mountedRef","fetchData","current","result","Date","err","console","startPolling","clearInterval","setInterval","stopPolling","refreshData"],"sources":["C:/xampp/htdocs/sms-frontend-clone/src/hooks/usePolling.js"],"sourcesContent":["/**\n * Custom React hook for polling data as WebSocket fallback\n */\nimport { useState, useEffect, useRef, useCallback } from 'react';\n\nconst usePolling = (fetchFunction, options = {}) => {\n  const {\n    interval = 5000,\n    enabled = true,\n    onSuccess,\n    onError,\n    dependencies = []\n  } = options;\n\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [lastUpdated, setLastUpdated] = useState(null);\n  \n  const intervalRef = useRef(null);\n  const mountedRef = useRef(true);\n\n  const fetchData = useCallback(async () => {\n    if (!enabled || !mountedRef.current) return;\n\n    try {\n      setLoading(true);\n      setError(null);\n      \n      const result = await fetchFunction();\n      \n      if (mountedRef.current) {\n        setData(result);\n        setLastUpdated(new Date());\n        onSuccess?.(result);\n      }\n    } catch (err) {\n      if (mountedRef.current) {\n        setError(err);\n        onError?.(err);\n        console.error('Polling error:', err);\n      }\n    } finally {\n      if (mountedRef.current) {\n        setLoading(false);\n      }\n    }\n  }, [fetchFunction, enabled, onSuccess, onError]);\n\n  const startPolling = useCallback(() => {\n    if (intervalRef.current) {\n      clearInterval(intervalRef.current);\n    }\n    \n    if (enabled) {\n      // Fetch immediately\n      fetchData();\n      \n      // Then set up interval\n      intervalRef.current = setInterval(fetchData, interval);\n    }\n  }, [fetchData, interval, enabled]);\n\n  const stopPolling = useCallback(() => {\n    if (intervalRef.current) {\n      clearInterval(intervalRef.current);\n      intervalRef.current = null;\n    }\n  }, []);\n\n  const refreshData = useCallback(() => {\n    fetchData();\n  }, [fetchData]);\n\n  // Start/stop polling based on enabled state\n  useEffect(() => {\n    if (enabled) {\n      startPolling();\n    } else {\n      stopPolling();\n    }\n\n    return () => {\n      stopPolling();\n    };\n  }, [enabled, startPolling, stopPolling, ...dependencies]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      mountedRef.current = false;\n      stopPolling();\n    };\n  }, [stopPolling]);\n\n  return {\n    data,\n    loading,\n    error,\n    lastUpdated,\n    refreshData,\n    startPolling,\n    stopPolling\n  };\n};\n\nexport default usePolling;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}