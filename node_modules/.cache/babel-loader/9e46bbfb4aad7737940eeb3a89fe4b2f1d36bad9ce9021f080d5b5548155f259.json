{"ast":null,"code":"var _s = $RefreshSig$();\n/**\n * Custom React hook for WebSocket connection with automatic reconnection\n */\nimport { useState, useEffect, useRef, useCallback } from 'react';\nconst useWebSocket = (url, options = {}) => {\n  _s();\n  const {\n    onMessage,\n    onOpen,\n    onClose,\n    onError,\n    reconnectInterval = 3000,\n    maxReconnectAttempts = 5,\n    protocols = [],\n    shouldReconnect = true\n  } = options;\n  const [socket, setSocket] = useState(null);\n  const [lastMessage, setLastMessage] = useState(null);\n  const [readyState, setReadyState] = useState(WebSocket.CONNECTING);\n  const [connectionStatus, setConnectionStatus] = useState('Connecting');\n  const reconnectTimeoutId = useRef(null);\n  const reconnectCount = useRef(0);\n  const socketRef = useRef(null);\n  const connect = useCallback(() => {\n    try {\n      const ws = new WebSocket(url, protocols);\n      socketRef.current = ws;\n      setSocket(ws);\n      ws.onopen = event => {\n        console.log('WebSocket connected:', url);\n        setReadyState(WebSocket.OPEN);\n        setConnectionStatus('Connected');\n        reconnectCount.current = 0;\n        onOpen === null || onOpen === void 0 ? void 0 : onOpen(event);\n      };\n      ws.onmessage = event => {\n        try {\n          const data = JSON.parse(event.data);\n          setLastMessage(data);\n          onMessage === null || onMessage === void 0 ? void 0 : onMessage(data, event);\n        } catch (error) {\n          console.error('Error parsing WebSocket message:', error);\n          setLastMessage(event.data);\n          onMessage === null || onMessage === void 0 ? void 0 : onMessage(event.data, event);\n        }\n      };\n      ws.onclose = event => {\n        console.log('WebSocket disconnected:', event.code, event.reason);\n        setReadyState(WebSocket.CLOSED);\n        setConnectionStatus('Disconnected');\n        setSocket(null);\n        socketRef.current = null;\n        onClose === null || onClose === void 0 ? void 0 : onClose(event);\n\n        // Attempt to reconnect if enabled and within retry limits\n        if (shouldReconnect && reconnectCount.current < maxReconnectAttempts) {\n          reconnectCount.current += 1;\n          setConnectionStatus(`Reconnecting... (${reconnectCount.current}/${maxReconnectAttempts})`);\n          reconnectTimeoutId.current = setTimeout(() => {\n            connect();\n          }, reconnectInterval);\n        } else if (reconnectCount.current >= maxReconnectAttempts) {\n          setConnectionStatus('Connection failed');\n        }\n      };\n      ws.onerror = event => {\n        console.error('WebSocket error:', event);\n        setConnectionStatus('Error');\n        onError === null || onError === void 0 ? void 0 : onError(event);\n      };\n    } catch (error) {\n      console.error('Error creating WebSocket connection:', error);\n      setConnectionStatus('Connection failed');\n    }\n  }, [url, protocols, onMessage, onOpen, onClose, onError, shouldReconnect, reconnectInterval, maxReconnectAttempts]);\n  const disconnect = useCallback(() => {\n    if (reconnectTimeoutId.current) {\n      clearTimeout(reconnectTimeoutId.current);\n    }\n    if (socketRef.current) {\n      socketRef.current.close();\n    }\n  }, []);\n  const sendMessage = useCallback(message => {\n    if (socketRef.current && socketRef.current.readyState === WebSocket.OPEN) {\n      const messageStr = typeof message === 'string' ? message : JSON.stringify(message);\n      socketRef.current.send(messageStr);\n      return true;\n    } else {\n      console.warn('WebSocket is not connected. Message not sent:', message);\n      return false;\n    }\n  }, []);\n  const sendJsonMessage = useCallback(message => {\n    return sendMessage(JSON.stringify(message));\n  }, [sendMessage]);\n\n  // Connect on mount\n  useEffect(() => {\n    connect();\n    return () => {\n      disconnect();\n    };\n  }, [connect, disconnect]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (reconnectTimeoutId.current) {\n        clearTimeout(reconnectTimeoutId.current);\n      }\n    };\n  }, []);\n  return {\n    socket,\n    lastMessage,\n    readyState,\n    connectionStatus,\n    sendMessage,\n    sendJsonMessage,\n    connect,\n    disconnect\n  };\n};\n_s(useWebSocket, \"aB7TbOL6dwaqK/Q7eDiJDP0rJtI=\");\nexport default useWebSocket;","map":{"version":3,"names":["useState","useEffect","useRef","useCallback","useWebSocket","url","options","_s","onMessage","onOpen","onClose","onError","reconnectInterval","maxReconnectAttempts","protocols","shouldReconnect","socket","setSocket","lastMessage","setLastMessage","readyState","setReadyState","WebSocket","CONNECTING","connectionStatus","setConnectionStatus","reconnectTimeoutId","reconnectCount","socketRef","connect","ws","current","onopen","event","console","log","OPEN","onmessage","data","JSON","parse","error","onclose","code","reason","CLOSED","setTimeout","onerror","disconnect","clearTimeout","close","sendMessage","message","messageStr","stringify","send","warn","sendJsonMessage"],"sources":["C:/xampp/htdocs/sms-frontend-clone/src/hooks/useWebSocket.js"],"sourcesContent":["/**\n * Custom React hook for WebSocket connection with automatic reconnection\n */\nimport { useState, useEffect, useRef, useCallback } from 'react';\n\nconst useWebSocket = (url, options = {}) => {\n  const {\n    onMessage,\n    onOpen,\n    onClose,\n    onError,\n    reconnectInterval = 3000,\n    maxReconnectAttempts = 5,\n    protocols = [],\n    shouldReconnect = true\n  } = options;\n\n  const [socket, setSocket] = useState(null);\n  const [lastMessage, setLastMessage] = useState(null);\n  const [readyState, setReadyState] = useState(WebSocket.CONNECTING);\n  const [connectionStatus, setConnectionStatus] = useState('Connecting');\n  \n  const reconnectTimeoutId = useRef(null);\n  const reconnectCount = useRef(0);\n  const socketRef = useRef(null);\n\n  const connect = useCallback(() => {\n    try {\n      const ws = new WebSocket(url, protocols);\n      socketRef.current = ws;\n      setSocket(ws);\n\n      ws.onopen = (event) => {\n        console.log('WebSocket connected:', url);\n        setReadyState(WebSocket.OPEN);\n        setConnectionStatus('Connected');\n        reconnectCount.current = 0;\n        onOpen?.(event);\n      };\n\n      ws.onmessage = (event) => {\n        try {\n          const data = JSON.parse(event.data);\n          setLastMessage(data);\n          onMessage?.(data, event);\n        } catch (error) {\n          console.error('Error parsing WebSocket message:', error);\n          setLastMessage(event.data);\n          onMessage?.(event.data, event);\n        }\n      };\n\n      ws.onclose = (event) => {\n        console.log('WebSocket disconnected:', event.code, event.reason);\n        setReadyState(WebSocket.CLOSED);\n        setConnectionStatus('Disconnected');\n        setSocket(null);\n        socketRef.current = null;\n        onClose?.(event);\n\n        // Attempt to reconnect if enabled and within retry limits\n        if (shouldReconnect && reconnectCount.current < maxReconnectAttempts) {\n          reconnectCount.current += 1;\n          setConnectionStatus(`Reconnecting... (${reconnectCount.current}/${maxReconnectAttempts})`);\n          \n          reconnectTimeoutId.current = setTimeout(() => {\n            connect();\n          }, reconnectInterval);\n        } else if (reconnectCount.current >= maxReconnectAttempts) {\n          setConnectionStatus('Connection failed');\n        }\n      };\n\n      ws.onerror = (event) => {\n        console.error('WebSocket error:', event);\n        setConnectionStatus('Error');\n        onError?.(event);\n      };\n\n    } catch (error) {\n      console.error('Error creating WebSocket connection:', error);\n      setConnectionStatus('Connection failed');\n    }\n  }, [url, protocols, onMessage, onOpen, onClose, onError, shouldReconnect, reconnectInterval, maxReconnectAttempts]);\n\n  const disconnect = useCallback(() => {\n    if (reconnectTimeoutId.current) {\n      clearTimeout(reconnectTimeoutId.current);\n    }\n    \n    if (socketRef.current) {\n      socketRef.current.close();\n    }\n  }, []);\n\n  const sendMessage = useCallback((message) => {\n    if (socketRef.current && socketRef.current.readyState === WebSocket.OPEN) {\n      const messageStr = typeof message === 'string' ? message : JSON.stringify(message);\n      socketRef.current.send(messageStr);\n      return true;\n    } else {\n      console.warn('WebSocket is not connected. Message not sent:', message);\n      return false;\n    }\n  }, []);\n\n  const sendJsonMessage = useCallback((message) => {\n    return sendMessage(JSON.stringify(message));\n  }, [sendMessage]);\n\n  // Connect on mount\n  useEffect(() => {\n    connect();\n    \n    return () => {\n      disconnect();\n    };\n  }, [connect, disconnect]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (reconnectTimeoutId.current) {\n        clearTimeout(reconnectTimeoutId.current);\n      }\n    };\n  }, []);\n\n  return {\n    socket,\n    lastMessage,\n    readyState,\n    connectionStatus,\n    sendMessage,\n    sendJsonMessage,\n    connect,\n    disconnect\n  };\n};\n\nexport default useWebSocket;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}